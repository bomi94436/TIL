(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{354:function(_,v,t){_.exports=t.p+"assets/img/IMG_2376.eca4b0b1.jpg"},364:function(_,v,t){"use strict";t.r(v);var i=t(42),p=Object(i.a)({},(function(){var _=this,v=_.$createElement,i=_._self._c||v;return i("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[i("h1",{attrs:{id:"객체지향의-사실과-오해"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#객체지향의-사실과-오해"}},[_._v("#")]),_._v(" 객체지향의 사실과 오해")]),_._v(" "),i("div",{staticStyle:{"text-align":"right"}},[_._v("2021.01.05")]),_._v(" "),i("h2",{attrs:{id:"책-정보"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#책-정보"}},[_._v("#")]),_._v(" 책 정보")]),_._v(" "),i("p",[_._v("제목: 객체지향의 사실과 오해 - 역할, 책임, 협력 관점에서 본 객체지향")]),_._v(" "),i("p",[_._v("저자: 조명호")]),_._v(" "),i("p",[_._v("출판사: 위키북스")]),_._v(" "),i("p",[_._v("출간일: 2015년 06월 17일")]),_._v(" "),i("p",[_._v("해당 책을 주관적으로 정리한 내용입니다.")]),_._v(" "),i("h2",{attrs:{id:"_01-협력하는-객체들의-공동체"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_01-협력하는-객체들의-공동체"}},[_._v("#")]),_._v(" 01 협력하는 객체들의 공동체")]),_._v(" "),i("p",[_._v("훌륭한 객체지향 설계자가 되기 위해 거쳐야 할 첫 번째 도전은 "),i("strong",[_._v("코드를 담는 클래스의 관점")]),_._v("에서 "),i("strong",[_._v("메시지를 주고받는 객체의 관점")]),_._v("으로 사고의 중심을 전환하는 것임")]),_._v(" "),i("p",[_._v("객체의 역할")]),_._v(" "),i("ul",[i("li",[_._v("여러 객체가 동일한 역할을 수행할 수 있음")]),_._v(" "),i("li",[_._v("역할은 대체 가능성을 의미함")]),_._v(" "),i("li",[_._v("각 객체는 책임을 수행하는 방법을 자율적으로 선택할 수 있음")]),_._v(" "),i("li",[_._v("하나의 객체가 동시에 여러 역할을 수행할 수 있음")])]),_._v(" "),i("h2",{attrs:{id:"_02-이상한-나라의-객체"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_02-이상한-나라의-객체"}},[_._v("#")]),_._v(" 02 이상한 나라의 객체")]),_._v(" "),i("p",[_._v("객체지향 패러다임의 목적은 현실 세계를 모방하는 것이 아니라 현실 세계를 기반으로 새로은 세계를 창조하는 것임")]),_._v(" "),i("p",[_._v("따라서 소프트웨어 세계에서 살아가는 객체는 현실 세계에서 존재하는 객체와는 전혀 다른 모습을 보이는 것이 일반적임")]),_._v(" "),i("p",[_._v("객체는 구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태를 가짐")]),_._v(" "),i("p",[_._v("객체와 객체 사이의 의미 있는 연결을 "),i("strong",[_._v("링크")]),_._v("(link)라고 함. 객체와 객체 사이에는 링크가 존재해야만 요청을 보내고 받을 수 있음(즉, 메세지를 주고 받을 수 있음). 이것은 일반적으로 한 객체가 다른 객체의 식별자를 알고 있는 것으로 표현됨.")]),_._v(" "),i("p",[_._v("상태와 행동 사이의 관계")]),_._v(" "),i("ul",[i("li",[_._v("객체의 행동은 상태에 영향을 받음")]),_._v(" "),i("li",[_._v("객체의 행동은 상태를 변경시킴")])]),_._v(" "),i("p",[_._v("상태라는 개념을 이용한 행동")]),_._v(" "),i("ul",[i("li",[_._v("상호작용이 현재의 상태에 어떤 방식으로 의존하는가")]),_._v(" "),i("li",[_._v("상호작용이 어떻게 현재의 상태를 변경시키는가")])]),_._v(" "),i("p",[_._v("객체의 행동은 다음의 두 가지 관점의 부수효과를 명확하게 서술해야 함")]),_._v(" "),i("ul",[i("li",[_._v("객체 자신의 상태 변경")]),_._v(" "),i("li",[_._v("행동 내에서 협력하는 다른 객체에 대한 메시지 전송")])]),_._v(" "),i("p",[_._v("상태를 잘 정의된 행동 집합 뒤로 캡슐화하는 것은 객체의 자율성을 높이고 협력을 단순하고 유연하게 만듦")]),_._v(" "),i("p",[_._v("식별자: 어떤 객체를 다른 객체와 구분하는 데 사용하는 객체의 프로퍼티임")]),_._v(" "),i("p",[_._v("값(값 객체, value object)은 식별자를 가지지 않기 때문에 상태를 이용한 동등성 검사를 통해 두 인스턴스를 비교해야 함")]),_._v(" "),i("p",[_._v("객체(참조 객체, reference object 또는 엔티티, entity)는 상태가 변경될 수 있기 때문에 식별자를 이용한 동일성 검사를 통해 두 인스턴스를 비교할 수 있음")]),_._v(" "),i("ul",[i("li",[_._v("객체는 상태를 가지며 상태는 변경 가능함")]),_._v(" "),i("li",[_._v("객체의 상태를 변경시키는 것은 객체의 행동임\n"),i("ul",[i("li",[_._v("행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있음")]),_._v(" "),i("li",[_._v("행동의 순서가 실행 결과에 영향을 미침")])])]),_._v(" "),i("li",[_._v("객체는 어떤 상태에 있더라도 유일하게 식별 가능함")])]),_._v(" "),i("p",[_._v("협력에 참여하는 훌륭한 객체 시민을 양성하기 위한 가장 중요한 덕목은 상태가 아니라 "),i("strong",[_._v("행동")]),_._v("에 초점을 맞추는 것임")]),_._v(" "),i("p",[_._v("객체지향 설계는 애플리케이션에 필요한 협력을 생각하고 협력에 참여하는 데 필요한 행동을 생각한 후 행동을 수행할 객체를 선택하는 방식으로 수행됨")]),_._v(" "),i("p",[_._v("행동이 상태를 결정한다")]),_._v(" "),i("blockquote",[i("p",[_._v("의인화의 관점에서 소프트웨어를 생물로 생각하자. 모든 생물처럼 소프트웨어는 태어나고, 삶을 영위하고, 그리고 죽는다[Wirfs-Brock 1990]")])]),_._v(" "),i("h2",{attrs:{id:"_03-타입과-추상화"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_03-타입과-추상화"}},[_._v("#")]),_._v(" 03 타입과 추상화")]),_._v(" "),i("blockquote",[i("p",[_._v("진정한 의미에서 추상화란 현실에서 출발하되 불필요한 부분을 도려내가면서 사물의 놀라운 본질을 드러나게 하는 과정이라고 할 수 있다[Root-Bernstein 2001].")])]),_._v(" "),i("p",[_._v("추상화")]),_._v(" "),i("p",[_._v(": 어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법")]),_._v(" "),i("p",[_._v("복잡성을 다루기 위해 추상화는 두 차원에서 이뤄진다[Kramer 2007].")]),_._v(" "),i("ul",[i("li",[_._v("첫 번째 차원은 구체적인 사물들 간의 "),i("strong",[_._v("공통점은 취하고 차이점은 버리는 일반화")]),_._v("를 통해 단순하게 만드는 것이다")]),_._v(" "),i("li",[_._v("두 번째 차원은 중요한 부분을 강조하기 위해 "),i("strong",[_._v("불필요한 세부 사항을 제거")]),_._v("함으로써 단순하게 만드는 것이다")])]),_._v(" "),i("p",[_._v("개념(concept): 공통점을 기반으로 객체들을 묶기 위한 그릇")]),_._v(" "),i("p",[_._v("개념의 세 가지 관점")]),_._v(" "),i("ul",[i("li",[_._v("심볼(symbol): 개념을 가리키는 간략한 이름이나 명칭")]),_._v(" "),i("li",[_._v("내연(intension): 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수 있음")]),_._v(" "),i("li",[_._v("외연(extension): 개념에 속하는 모든 객체의 집합(set)")])]),_._v(" "),i("p",[_._v("분류: 객체에 특정한 개념을 적용하는 작업")]),_._v(" "),i("p",[_._v("타입(개념): 공통점을 기반으로 객체들을 묶기 위한 틀")]),_._v(" "),i("p",[_._v("데이터 타입은 메모리 안에 저장된 데이터의 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터다. 데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다.")]),_._v(" "),i("p",[_._v("객체의 내부 표현 방식이 다르더라도 어떤 객체들이 동일하게 행동한다면 그 객체들은 동일한 타입에 속한다.")]),_._v(" "),i("p",[_._v("객체지향에서 일반화/특수화 관계를 결정하는 것은 객체의 상태를 표현하는 데이터가 아니라 행동이다")]),_._v(" "),i("p",[_._v("타입은 시간에 따라 동적으로 변하는 객체의 상태를 시간과 무관한 정적인 모습으로 다룸으로써 복잡성을 단순화할 수 있게 해준다.")]),_._v(" "),i("p",[_._v("동적 모델(dynamic model): 객체가 살아 움직이는 동안 상태가 어떻게 변하고 어떻게 행동하는지를 포착하는 것")]),_._v(" "),i("p",[_._v("정적 모델(static model): 객체가 가질 수 있는 모든 상태와 모든 행동을 시간에 독립적으로 표현하는 것")]),_._v(" "),i("p",[_._v("객체지향 애플리케이션을 설계하고 구현하기 위해서는 객체 관점의 동적 모델과 객체를 추상화한 타입 관점의 정적 모델을 적절히 혼용해야 함")]),_._v(" "),i("h2",{attrs:{id:"_04-역할-책임-협력"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_04-역할-책임-협력"}},[_._v("#")]),_._v(" 04 역할, 책임, 협력")]),_._v(" "),i("p",[_._v("협력: 한 사람이 다른 사람에게 도움을 "),i("strong",[_._v("요청")]),_._v("할 때 시작됨. 요청을 받은 사람은 일을 처리한 후 요청한 사람에게 필요한 지식이나 서비스를 제공하는 것으로 요청에 "),i("strong",[_._v("응답")]),_._v("됨.")]),_._v(" "),i("p",[_._v("책임: 객체지향의 세계에서는 어떤 객체가 어떤 요청에 대해 대답해 줄 수 있거나, 적절한 행동을 할 의무가 있는 경우 해당 객체가 책임을 가진다고 말함. 결국 어떤 대상에 대한 요청은 그 대상이 요청을 처리할 책임이 있음을 암시함.")]),_._v(" "),i("p",[_._v("객체의 책임은 '객체가 무엇을 알고 있는가(knowing)'와 '무엇을 할 수 있는가(doing)'로 구성됨.")]),_._v(" "),i("ul",[i("li",[_._v("하는 것(doing)\n"),i("ul",[i("li",[_._v("객체를 생성하거나 계산을 하는 등의 스스로 하는 것")]),_._v(" "),i("li",[_._v("다른 객체의 행동을 시작시키는 것")]),_._v(" "),i("li",[_._v("다른 객체의 활동을 제어하고 조절하는 것")])])]),_._v(" "),i("li",[_._v("아는 것(knowing)\n"),i("ul",[i("li",[_._v("개인적인 정보에 관해 아는 것")]),_._v(" "),i("li",[_._v("관련된 객체에 관해 아는 것")]),_._v(" "),i("li",[_._v("자신이 유도하거나 계산할 수 있는 것에 관해 아는 것")])])])]),_._v(" "),i("p",[_._v("책임은 객체의 외부에 제공해 줄 수 있는 정보(아는 것의 측면)와 외부에 제공해 줄 수 있는 서비스(하는 것의 측면)의 목록임. 따라서 책임은 객체의 공용 인터페이스(public interface)를 구성함.")]),_._v(" "),i("p",[_._v("메시지 전송(message-send): 객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것")]),_._v(" "),i("p",[_._v("책임과 메시지 수준이 일대일 대응은 아님(하나의 책임에 대해 여러 메세지로 요청할 수 있음)")]),_._v(" "),i("p",[_._v("역할은 협력 내에서 다른 객체로 대체할 수 있음을 나타내는 일종의 표식임")]),_._v(" "),i("p",[_._v("객체가 역할을 대체 가능하기 위해서는 협력 안에서 역할이 수행하는 모든 책임을 동일하게 수행할 수 있어야 함. 즉, 역할의 대체 가능성은 행위 호환성을 의미하고, 행위 호환성은 동일한 책임의 수행을 의미함.")]),_._v(" "),i("p",[_._v("올바른 객체를 설계하기 위해서는 먼저 견고하고 깔끔한 협력을 설계해야 함. 협력을 설계한다는 것은 설계에 참여하는 객체들이 주고받을 요청과 응답의 흐름을 결정한다는 것을 의미함.")]),_._v(" "),i("p",[_._v("객체를 충분히 협력적으로 만든 후에 협력이라는 문맥 안에서 객체를 충분히 자율적으로 만든다.")]),_._v(" "),i("p",[_._v("역할, 책임, 협력의 관점에서 애플리케이션을 설계하는 유용한 세 가지 기법")]),_._v(" "),i("ul",[i("li",[i("p",[_._v("책임-주도 설계(Responsibility-Driven Desing)")]),_._v(" "),i("p",[_._v("설계 절차")]),_._v(" "),i("ul",[i("li",[_._v("시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다")]),_._v(" "),i("li",[_._v("시스템 책임을 더 작은 책임으로 분할한다")]),_._v(" "),i("li",[_._v("분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다")]),_._v(" "),i("li",[_._v("객체가 책임을 수행하는 중에 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다")]),_._v(" "),i("li",[_._v("해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 된다")])])]),_._v(" "),i("li",[i("p",[_._v("디자인 패턴(Design Pattern)")]),_._v(" "),i("p",[_._v("책임-주도 설계는 객체의 역할, 책임, 협력을 고안하기 위한 방법과 절차를 제시하는 반면, 디자인 패턴은 책임-주도 설계의 결과를 표현함.")])]),_._v(" "),i("li",[i("p",[_._v("테스트-주도 개발(Test-Driven Development)")])])]),_._v(" "),i("p",[_._v("테스트-주도 개발은 테스트를 작성하는 것이 아니라 책임을 수행할 객체 또는 클라이언트가 기대하는 객체의 역할이 메시지를 수신할 때 어떤 결과를 반환하고 그 과정에서 어떤 객체와 협력할 것인지에 대한 기대를 코드의 형태로 작성하는 것이다.")]),_._v(" "),i("h2",{attrs:{id:"_05-책임과-메시지"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_05-책임과-메시지"}},[_._v("#")]),_._v(" 05 책임과 메시지")]),_._v(" "),i("p",[_._v("객체가 책임을 자율적으로 수행하기 위해서는 객체에게 할당되는 책임이 자율적이어야 함")]),_._v(" "),i("p",[_._v("어떤 책임이 자율적인지를 판단하는 기준은 문맥에 따라 다르다는 사실에 유의")]),_._v(" "),i("p",[_._v("자율적인 책임의 특징은 객체가 '어떻게(how)' 해야 하는가가 아니라 '무엇(what)'을 해야 하는가를 설명한다는 것임")]),_._v(" "),i("p",[_._v("다형성: 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것")]),_._v(" "),i("p",[_._v("다형성을 사용하면 송신자가 수신자의 종류를 모르더라도 메시지를 전송할 수 있다. 즉, 다형성은 수신자의 종류를 캡슐화한다.")]),_._v(" "),i("p",[_._v("훌륭한 객체지향 설계는 어떤 객체가 어떤 메시지를 전송할 수 있는가와 어떤 객체가 어떤 메시지를 이해할 수 있는가를 중심으로 객체 사이의 협력 관계를 구성하는 것이다.")]),_._v(" "),i("p",[_._v("책임-주도 설계의 핵심은 어떤 행위(메시지)가 필요한지를 먼저 결정한 후에 이 행위를 수행할 객체를 결정하는 것임. 이 과정을 흔히 "),i("strong",[_._v("What/Who 사이클")]),_._v("[Budd 2001]이라고 함.")]),_._v(" "),i("p",[_._v("객체가 어떤 메시지를 수신하고 처리할 수 있느냐가 객체의 책임을 결정한다.")]),_._v(" "),i("p",[_._v("책임-주도 설계 방법에서는 What/Who 사이클에 따라 협력에 참여할 객체를 결정하기 전에 협력에 필요한 메시지를 먼저 결정한다.")]),_._v(" "),i("p",[_._v("메시지가 결정된 후에야 메시지를 수신할 후보를 선택하는 것으로 초점이 이동된다.")]),_._v(" "),i("p",[_._v("묻지 말고 시켜라(Tell, Don't Ask) 스타일 또는 "),i("strong",[_._v("데메테르 법칙(Law of Demeter)")]),_._v("[Lieberherr 1988]")]),_._v(" "),i("p",[_._v(": 메시지를 먼저 결정하고 객체가 메시지를 따르게 하는 설계방식.")]),_._v(" "),i("p",[_._v(": 객체가 외부에 제공하는 인터페이스가 독특한 스타일을 따르게 함.")]),_._v(" "),i("p",[_._v(": 메시지를 결정하는 시점에는 어떤 객체가 미시지를 수신할 것인지를 알 수 없기 때문에 당연히 메시지 송신자는 메시지를 수신할 객체의 내부 상태를 볼 수 없음(= 메시지 수신자의 캡슐화 증진)")]),_._v(" "),i("p",[_._v(": 송신자가 수신자의 내부 상태를 미리 알 수 없기 때문에 송신자와 수신자가 느슨하게 결합됨")]),_._v(" "),i("p",[_._v(": 객체는 다른 객체의 상태를 묻지 말아야 함")]),_._v(" "),i("p",[_._v("인터페이스: 어떤 두 사물이 마주치는 경계 지점에서 서로 상호작용할 수 있게 이어주는 방법이나 장치")]),_._v(" "),i("p",[_._v("특징")]),_._v(" "),i("ul",[i("li",[_._v("인터페이스의 사용법을 익히기만 하면 내부 구조나 동작 방식을 몰라도 쉽게 대상을 조작하거나 의사를 전달할 수 있다.")]),_._v(" "),i("li",[_._v("인터페이스 자체는 변경하지 않고 단순히 내부 구성이나 작동 방식만을 변경하는 것은 인터페이스 사용자에게 어떤 영향도 미치지 않는다.")]),_._v(" "),i("li",[_._v("대상이 변경되더라도 동일한 인터페이스를 제공하기만 하면 아무런 문제 없이 상호작용할 수 있다.")])]),_._v(" "),i("p",[_._v("공용 인터페이스: 외부에 공개된 인터페이스")]),_._v(" "),i("p",[_._v("객체지향에서 모든 상호작용은 메시지를 통해서만 이뤄져야 하며 자기 자신과의 상호작용 역시 예외가 아니다.")]),_._v(" "),i("p",[_._v("객체가 협력에 참여하기 위해 수행하는 메시지가 객체의 공용 인터페이스의 모양을 암시함")]),_._v(" "),i("p",[_._v("객체지향의 힘은 대부분 외부와 내부를 구분하는 것에서 나온다")]),_._v(" "),i("p",[_._v("인터페이스에서 필요한 원칙[Weisfeld 2008]")]),_._v(" "),i("ul",[i("li",[_._v("좀 더 추상적인 인터페이스")]),_._v(" "),i("li",[_._v("최소 인터페이스")]),_._v(" "),i("li",[_._v("인터페이스와 구현 간에 차이가 있다는 점을 인식")])]),_._v(" "),i("p",[_._v("구현(implementation)")]),_._v(" "),i("p",[_._v(": 객체지향의 세계에서 내부 구조와 작동 방식을 가리키는 고유 용어")]),_._v(" "),i("p",[_._v(": 객체를 구성하지만 공용 인터페이스에 포함되지 않는 모든 것이 구현에 포함됨")]),_._v(" "),i("p",[_._v("객체의 외부와 내부를 분리하라는 것은 결국 객체의 공용 인터페이스와 구현을 명확하게 분리하라는 말과 동일하다")]),_._v(" "),i("p",[_._v("훌륭한 객체란 구현을 모른 채 인터페이스만 알면 쉽게 상호작용할 수 있는 객체를 의미한다")]),_._v(" "),i("p",[_._v("인터페이스와 구현의 분리 원칙(separation of interface and implementation): 객체를 설계할 때 객체 외부에 노출되는 인터페이스와 객체의 내부에 숨겨지는 구현을 명확하게 분리해서 고려해야 한다는 것")]),_._v(" "),i("p",[_._v("객체 내부 - 객체의 상태, 메서드 구현")]),_._v(" "),i("p",[_._v("객체 외부 - 공용 인터페이스")]),_._v(" "),i("p",[_._v("캡슐화(정보 은닉, informatin hiding): 객체의 자율성을 보존하기 위해 구현을 외부로부터 감추는 것")]),_._v(" "),i("p",[_._v("캡슐화가 사용되는 두 가지 관점")]),_._v(" "),i("ul",[i("li",[_._v("상태와 행위의 캡슐화(데이터 캡슐화, data encapsulation)")]),_._v(" "),i("li",[_._v("사적인 비밀의 캡슐화")])]),_._v(" "),i("p",[_._v("책임이 얼마나 자율적인지가 전체적인 협력의 설계 품질을 결정하는 이유")]),_._v(" "),i("ol",[i("li",[_._v("자율적인 책임은 협력을 단순하게 만든다")]),_._v(" "),i("li",[_._v("자율적인 책임은 모자 장수의 외부와 내부를 명확하게 분리한다")]),_._v(" "),i("li",[_._v("책임이 자율적일 경우 책임을 수행하는 내부적인 방법을 변경하더라도 외부에 영향을 미치지 않는다")]),_._v(" "),i("li",[_._v("자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공한다")]),_._v(" "),i("li",[_._v("객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워진다")])]),_._v(" "),i("p",[_._v("객체의 책임이 자율적일수록")]),_._v(" "),i("ul",[i("li",[_._v("적절히 추상화된다")]),_._v(" "),i("li",[_._v("응집도가 높아진다")]),_._v(" "),i("li",[_._v("결합도가 낮아진다")]),_._v(" "),i("li",[_._v("캡슐화가 증진된다")]),_._v(" "),i("li",[_._v("인터페이스와 구현이 명확히 분리된다")]),_._v(" "),i("li",[_._v("설계의 유연성과 재사용성이 향상된다")])]),_._v(" "),i("h2",{attrs:{id:"_06-객체-지도"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_06-객체-지도"}},[_._v("#")]),_._v(" 06 객체 지도")]),_._v(" "),i("p",[_._v("여행 중 길을 모를 때, 해결 방법")]),_._v(" "),i("ol",[i("li",[_._v("다른 사람에게 길을 물어본다 = 기능적이고 해결책 지향적인 접근법(functional, solution-directed approach) → 전통적인 소프트웨어 개발 방법과 유사")]),_._v(" "),i("li",[_._v("지도를 이용한다 = 구조적이고 문제 지향적인 접근법(structural, problem-directed approach) → 객체지향 개발 방법과 유사")])]),_._v(" "),i("p",[_._v("지도가 범용적인 이유 = 지도를 사용하려는 사람들이 원하는 "),i("strong",[_._v("기능")]),_._v("에 비해 지도에 표시된 "),i("strong",[_._v("구조")]),_._v("가 더 안정적이기 때문")]),_._v(" "),i("p",[_._v("소프트웨어 제품 설계의 두 가지 측면")]),_._v(" "),i("ul",[i("li",[i("strong",[_._v("기능(function)")]),_._v(" 측면의 설계: 제품이 사용자를 위해 무엇을 할 수 있는지에 초점을 맞춤")]),_._v(" "),i("li",[i("strong",[_._v("구조(structure)")]),_._v(" 측면의 설계: 제품의 형태가 어떠해야 하는지에 초점을 맞춤")])]),_._v(" "),i("p",[_._v("설계라는 행위를 중요하게 만드는 것은 변경(예 - 요구사항)에 대한 필요성이다")]),_._v(" "),i("p",[_._v("미래에 대비하는 가장 좋은 방법은 변경을 예측하는 것이 아니라 변경을 수용할 수 있는 선택의 여지를 설계에 마련해 놓는 것이다")]),_._v(" "),i("p",[_._v("객체지향 세계를 구축하기 위한 재료")]),_._v(" "),i("ul",[i("li",[_._v("사용자에게 제공할 "),i("strong",[_._v("기능")])]),_._v(" "),i("li",[_._v("기능을 담을 안정적인 "),i("strong",[_._v("구조")])])]),_._v(" "),i("p",[_._v("재료를 구하는 곳")]),_._v(" "),i("ul",[i("li",[_._v("구조 - 사용자나 이해관계자들이 도메인(domain)에 관해 생각하는 개념과 개념들 간의 관계로 표현(도메인 모델링)")]),_._v(" "),i("li",[_._v("기능 - 사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템의 행위로 표현(유스케이스 모델링)")])]),_._v(" "),i("p",[_._v("도메인: 사용자가 프로그램을 사용하는 대상 분야")]),_._v(" "),i("p",[_._v("도메인 모델: 사용자가 프로그램을 사용하는 대상 영역에 관한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태")]),_._v(" "),i("p",[_._v("멘탈 모델: 사람들이 자기 자신, 다른 사람, 환경, 자신이 상호작용하는 사물들에 대해 갖는 모형")]),_._v(" "),i("p",[_._v("도널드 노먼(Donald Norman)은 제품을 설계할 때 제품에 관한 모든 것이 사용자들이 제품에 대해 가지고 있는 멘탈 모델과 정확하게 일치해야 한다고 주장함[Norman 1988].")]),_._v(" "),i("p",[_._v("도메인 모델은 도메인에 대한 사용자 모델, 디자인 모델, 시스템 이미지를 포괄하도록 추상화한 소프트웨어 모델임. 따라서 도메인 모델은 소프트웨어에 대한 멘탈 모델임.")]),_._v(" "),i("p",[_._v("객체지향을 이용하면 도메인에 대한 사용자 모델, 디자인 모델, 시스템 이미지 모두가 유사한 모습을 유지하도록 만드는 것이 가능함. 객체지향의 이러한 특징을 "),i("strong",[_._v("연결완전성")]),_._v("[Walden 1995], 또는 "),i("strong",[_._v("표현적 차이")]),_._v("[Larman 2001]라고 함.")]),_._v(" "),i("p",[_._v("소프트웨어 객체와 현실 객체 사이의 관계를 가장 효과적으로 표현할 수 있는 단어는 "),i("strong",[_._v("은유임")]),_._v(".")]),_._v(" "),i("p",[_._v("소프트웨어 객체와 현실 객체 사이의 의미적 거리를 가리켜 "),i("strong",[_._v("표현적 차이")]),_._v(" 또는 "),i("strong",[_._v("의미적 차이")]),_._v("라고 함[Larman 2001].")]),_._v(" "),i("p",[_._v("소프트웨어 객체를 창조하기 위해 우리가 은유해야 하는 대상은 도메인 모델임.")]),_._v(" "),i("p",[_._v("기능적 요구사항: 시스템이 사용자에게 제공해야 하는 기능의 목록을 정리한 것")]),_._v(" "),i("p",[_._v("유스케이스")]),_._v(" "),i("p",[_._v(": 사용자의 목표를 달성하기 위해 사용자와 시스템 간에 이뤄지는 상호작용의 흐름을 텍스트로 정리한 것")]),_._v(" "),i("p",[_._v(": 사용자들의 목표를 중심으로 시스템의 기능적인 요구사항들을 이야기 형식으로 묶을 수 있음")]),_._v(" "),i("p",[_._v("유스케이스의 특성")]),_._v(" "),i("ol",[i("li",[_._v("유스케이스는 사용자와 시스템 간의 상호작용을 보여주는 '텍스트'다. 다이어그램이 아니다.")]),_._v(" "),i("li",[_._v("유스케이스는 하나의 시나리오가 아니라 여러 시나리오들의 집합이다.")]),_._v(" "),i("li",[_._v("유스케이스는 단순한 피처(feature) 목록과 다르다.")]),_._v(" "),i("li",[_._v("유스케이스는 사용자 인터페이스와 관련된 세부 정보를 포함하지 말아야 한다.")]),_._v(" "),i("li",[_._v("유스케이스는 내부 설계와 관련된 정보를 포함하지 않는다.")])]),_._v(" "),i("p",[i("img",{attrs:{src:t(354),alt:"객체지향 설계의 흐름"}})]),_._v(" "),i("p",[_._v("책임-주도 설계 방법은 시스템의 기능을 역할과 책임을 수행하는 객체들의 협력 관계로 바라보게 함으로써 두 가지 기본 재료인 유스케이스와 도메인 모델을 통합함.")]),_._v(" "),i("p",[_._v("책임 할당의 기본 원칙은 책임을 수행하는 데 필요한 정보를 가진 객체에게 그 책임을 할당하는 것임.")]),_._v(" "),i("p",[_._v("가역성(reversibility)[Walden 1995]: 모델에서 코드로의 매끄러운 흐름을 의미하는 연결 완전성과 반대로 코드에서 모델로의 매끄러운 흐름을 의미함")]),_._v(" "),i("h2",{attrs:{id:"_07-함께-모으기"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_07-함께-모으기"}},[_._v("#")]),_._v(" 07 함께 모으기")]),_._v(" "),i("p",[_._v("객체지향 설계 안에 존재하는 세 가지 관점")]),_._v(" "),i("ul",[i("li",[i("p",[_._v("개념 관점(Conceptual Perspective)")]),_._v(" "),i("p",[_._v(": 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현")])]),_._v(" "),i("li",[i("p",[_._v("명세 관점(Specification Perspective)")]),_._v(" "),i("p",[_._v(": 도메인의 개념이 아닌 객체들의 책임에 초점을 맞춤")]),_._v(" "),i("p",[_._v(": 객체가 협력을 위해 '무엇'을 할 수 있는가")])]),_._v(" "),i("li",[i("p",[_._v("구현 관점(Implementation Perspective)")]),_._v(" "),i("p",[_._v(": 객체들이 책임을 수행하는 데 필요한 동작하는 코드를 작성하는 것에 초점을 맞춤")]),_._v(" "),i("p",[_._v(": 객체의 책임을 '어떻게' 수행할 것인가")])])]),_._v(" "),i("p",[_._v("개념 관점, 명세 관점, 구현 관점은 동일한 클래스를 세 가지 다른 방향에서 바라보는 것을 의미함")]),_._v(" "),i("ul",[i("li",[_._v("클래스가 은유하는 도메인 - 개념 관점")]),_._v(" "),i("li",[_._v("클래스의 공용 인터페이스 - 명세 관점")]),_._v(" "),i("li",[_._v("클래스의 속성과 메서드 - 구현 관점")])]),_._v(" "),i("p",[_._v("클래스는 세 가지 관점을 모두 수용할 수 있도록 개념, 인터페이스, 구현을 함께 드러내는 동시에 코드 안에서 세 가지 관점을 쉽게 식별할 수 있도록 깔끔하게 분리해야 함")])])}),[],!1,null,null,null);v.default=p.exports}}]);